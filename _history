{"entries":[{"timestamp":1749753369979,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"namespace siphash {\n    const KEY0 = 0x07060504\n    const KEY1 = 0x03020100\n    const KEY2 = 0x0f0e0d0c\n    const KEY3 = 0x0b0a0908\n\n    function rotl(x: number, b: number): number {\n        return ((x << b) | (x >>> (32 - b))) >>> 0\n    }\n\n    // Rotate left for 64-bit split into two 32-bit halves\n    function rotl64(lo: number, hi: number, b: number): [number, number] {\n        if (b === 32) return [hi, lo]\n        else if (b < 32) {\n            let newHi = (hi << b) | (lo >>> (32 - b))\n            let newLo = (lo << b) | (hi >>> (32 - b))\n            return [newLo >>> 0, newHi >>> 0]\n        } else {\n            // b > 32\n            b -= 32\n            let newHi = (lo << b) | (hi >>> (32 - b))\n            let newLo = (hi << b) | (lo >>> (32 - b))\n            return [newLo >>> 0, newHi >>> 0]\n        }\n    }\n\n    // 64-bit addition (two 32-bit halves)\n    function add64(aLo: number, aHi: number, bLo: number, bHi: number): [number, number] {\n        let lo = (aLo + bLo) >>> 0\n        let carry = (lo < aLo) ? 1 : 0\n        let hi = (aHi + bHi + carry) >>> 0\n        return [lo, hi]\n    }\n\n    // 64-bit xor\n    function xor64(aLo: number, aHi: number, bLo: number, bHi: number): [number, number] {\n        return [(aLo ^ bLo) >>> 0, (aHi ^ bHi) >>> 0]\n    }\n\n    // Converts 8 bytes from array starting at offset into two 32-bit words (little endian)\n    function bytesTo64LE(bytes: number[], offset: number): [number, number] {\n        let lo = 0, hi = 0\n        for (let i = 0; i < 4; i++) {\n            lo |= (bytes[offset + i] || 0) << (8 * i)\n            hi |= (bytes[offset + 4 + i] || 0) << (8 * i)\n        }\n        return [lo >>> 0, hi >>> 0]\n    }\n\n    // Converts two 32-bit words back to number (just returns low 32 bits as number)\n    // For simplicity, hash output is truncated to 32 bits\n    // You can extend this to return a hex string combining both parts if needed\n\n    export function hash(message: string): number {\n        let m = stringToBytes(message)\n        let b = m.length\n\n        // Initialize state with key and constants\n        let v0 = [KEY0 ^ 0x736f6d65, KEY1 ^ 0x70736575] // low, high\n        let v1 = [KEY2 ^ 0x646f7261, KEY3 ^ 0x6e646f6d]\n        let v2 = [KEY0 ^ 0x6c796765, KEY1 ^ 0x6e657261]\n        let v3 = [KEY2 ^ 0x74656462, KEY3 ^ 0x79746573]\n\n        let offset = 0\n\n        // Process all 8-byte blocks\n        while (offset + 8 <= b) {\n            let mi = bytesTo64LE(m, offset)\n            v3 = xor64(v3[0], v3[1], mi[0], mi[1])\n            [v0, v1, v2, v3] = sipround(v0, v1, v2, v3, 2)\n            v0 = xor64(v0[0], v0[1], mi[0], mi[1])\n            offset += 8\n        }\n\n        // Build last block with padding\n        let lastBlock = new Array(8).fill(0)\n        let remaining = b - offset\n        for (let i = 0; i < remaining; i++) {\n            lastBlock[i] = m[offset + i]\n        }\n        lastBlock[7] = b & 0xff\n\n        let mi = bytesTo64LE(lastBlock, 0)\n        v3 = xor64(v3[0], v3[1], mi[0], mi[1])\n        [v0, v1, v2, v3] = sipround(v0, v1, v2, v3, 2)\n        v0 = xor64(v0[0], v0[1], mi[0], mi[1])\n\n        v2 = xor64(v2[0], v2[1], 0xff, 0)\n\n        [v0, v1, v2, v3] = sipround(v0, v1, v2, v3, 4)\n\n        let result = xor64(xor64(v0[0], v0[1], v1[0], v1[1])[0], xor64(v0[0], v0[1], v1[0], v1[1])[1],\n            xor64(v2[0], v2[1], v3[0], v3[1])[0], xor64(v2[0], v2[1], v3[0], v3[1])[1])\n\n        // Return low 32 bits\n        return result[0] >>> 0\n    }\n\n    // SipRound function: mutates state 2-4 times\n    function sipround(v0: [number, number], v1: [number, number], v2: [number, number], v3: [number, number], rounds: number): [[number, number], [number, number], [number, number], [number, number]] {\n        for (let i = 0; i < rounds; i++) {\n            let res = add64(v0[0], v0[1], v1[0], v1[1])\n            v0 = res\n            v1 = rotl64(v1[0], v1[1], 13)\n            v1 = xor64(v1[0], v1[1], v0[0], v0[1])\n            v0 = rotl64(v0[0], v0[1], 32)\n\n            res = add64(v2[0], v2[1], v3[0], v3[1])\n            v2 = res\n            v3 = rotl64(v3[0], v3[1], 16)\n            v3 = xor64(v3[0], v3[1], v2[0], v2[1])\n\n            res = add64(v0[0], v0[1], v3[0], v3[1])\n            v0 = res\n            v3 = rotl64(v3[0], v3[1], 21)\n            v3 = xor64(v3[0], v3[1], v0[0], v0[1])\n\n            res = add64(v2[0], v2[1], v1[0], v1[1])\n            v2 = res\n            v1 = rotl64(v1[0], v1[1], 17)\n            v1 = xor64(v1[0], v1[1], v2[0], v2[1])\n            v2 = rotl64(v2[0], v2[1], 32)\n        }\n        return [v0, v1, v2, v3]\n    }\n\n    // Convert string to UTF-8 byte array\n    function stringToBytes(str: string): number[] {\n        let bytes: number[] = []\n        for (let i = 0; i < str.length; i++) {\n            let code = str.charCodeAt(i)\n            if (code < 0x80) {\n                bytes.push(code)\n            } else if (code < 0x800) {\n                bytes.push(0xc0 | (code >> 6))\n                bytes.push(0x80 | (code & 0x3f))\n            } else {\n                bytes.push(0xe0 | (code >> 12))\n                bytes.push(0x80 | ((code >> 6) & 0x3f))\n                bytes.push(0x80 | (code & 0x3f))\n            }\n        }\n        return bytes\n    }\n}\n\n\nlet deviceNum = control.deviceSerialNumber()\ndeviceNum = deviceNum.toString()\nlet key = siphash.hash(deviceNum)\n\nconsole.log(deviceNum)\nconsole.log(key)\n"],[0,"\n"]],"start1":0,"start2":0,"length1":5342,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"pt-only\""],[1,",\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":275,"start2":275,"length1":11,"length2":42}]}]},{"timestamp":1749753930240,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"h {\n"],[-1,"    // Hardcoded 128-bit key split into four 32-bit parts (little-endian)\n"],[0,"    "]],"start1":16,"start2":16,"length1":82,"length2":8},{"diffs":[[0,"08\n\n"],[-1,"    // Rotate left 32-bit\n"],[0,"    "]],"start1":129,"start2":129,"length1":34,"length2":8},{"diffs":[[0,"eft "],[1,"for "],[0,"64-bit "],[-1,"represented by lo and hi part"],[1,"split into two 32-bit halve"],[0,"s\n  "]],"start1":256,"start2":256,"length1":44,"length2":46},{"diffs":[[0,"mber"],[-1,", out: number[]): void {\n        b = b % 64"],[1,"): [number, number] {"],[0,"\n   "]],"start1":349,"start2":349,"length1":51,"length2":29},{"diffs":[[0,"b =="],[-1," 0) {\n            out[0] = lo\n            out[1] = hi"],[1,"= 32) return [hi, lo]"],[0,"\n       "],[-1," }"],[0," els"]],"start1":387,"start2":387,"length1":71,"length2":37},{"diffs":[[0,"    "],[-1,"out[0]"],[1,"let newHi"],[0," = ("],[-1,"(lo"],[1,"hi"],[0," << "]],"start1":448,"start2":448,"length1":21,"length2":23},{"diffs":[[0,"hi << b) | ("],[-1,"hi"],[1,"lo"],[0," >>> (32 - b"]],"start1":465,"start2":465,"length1":26,"length2":26},{"diffs":[[0,">> (32 - b))"],[-1,") >>> 0"],[0,"\n"],[1," "],[0,"            "]],"start1":481,"start2":481,"length1":32,"length2":26},{"diffs":[[0,"    "],[-1," out[1]"],[1,"let newLo"],[0," = ("],[-1,"(hi"],[1,"lo"],[0," << "]],"start1":502,"start2":502,"length1":22,"length2":23},{"diffs":[[0," = (lo << b) | ("],[-1,"lo"],[1,"hi"],[0," >>> (32 - b))) "]],"start1":515,"start2":515,"length1":34,"length2":34},{"diffs":[[0,">> (32 - b))"],[-1,") >>> 0"],[0,"\n        } e"]],"start1":535,"start2":535,"length1":31,"length2":24},{"diffs":[[0,"    "],[-1,"} else if (b == 32) {\n            out[0] = hi\n            out[1] = lo\n        } else {\n            let bb = b - 32"],[1,"    return [newLo >>> 0, newHi >>> 0]\n        } else {\n            // b > 32\n            b -= 32\n            let newHi = (lo << b) | (hi >>> (32 - b))"],[0,"\n   "]],"start1":552,"start2":552,"length1":122,"length2":158},{"diffs":[[0,"    "],[-1,"out[0]"],[1,"let newLo"],[0," = "],[-1,"("],[0,"(hi << "],[-1,"b"],[0,"b) |"]],"start1":715,"start2":715,"length1":26,"length2":27},{"diffs":[[0,"o >>> (32 - "],[-1,"b"],[0,"b))"],[-1,") >>> 0"],[0,"\n           "]],"start1":745,"start2":745,"length1":35,"length2":27},{"diffs":[[0,"    "],[-1,"out[1] = ((lo << bb) | (hi >>> (32 - bb)))"],[1,"return [newLo >>> 0, newHi"],[0," >>> 0"],[1,"]"],[0,"\n   "]],"start1":769,"start2":769,"length1":56,"length2":41},{"diffs":[[0,"ion "],[-1,"with carry"],[1,"(two 32-bit halves)"],[0,"\n   "]],"start1":843,"start2":843,"length1":18,"length2":27},{"diffs":[[0,": number"],[-1,", out: number[]): void"],[1,"): [number, number]"],[0," {\n     "]],"start1":928,"start2":928,"length1":38,"length2":35},{"diffs":[[0,"ry ="],[-1," 0\n        if"],[0," (lo"]],"start1":1008,"start2":1008,"length1":21,"length2":8},{"diffs":[[0,"Lo) "],[-1,"carry = 1"],[1,"? 1 : 0"],[0,"\n   "]],"start1":1020,"start2":1020,"length1":17,"length2":15},{"diffs":[[0,"    "],[-1,"out[0] = lo\n        out[1] ="],[1,"return [lo,"],[0," hi"],[1,"]"],[0,"\n   "]],"start1":1079,"start2":1079,"length1":39,"length2":23},{"diffs":[[0,": number"],[-1,", out: number[]): void"],[1,"): [number, number]"],[0," {\n     "]],"start1":1185,"start2":1185,"length1":38,"length2":35},{"diffs":[[0,"        "],[-1,"out[0] = "],[1,"return ["],[0,"(aLo ^ b"]],"start1":1215,"start2":1215,"length1":25,"length2":24},{"diffs":[[0,"o) >>> 0"],[-1,"\n        out[1] ="],[1,","],[0," (aHi ^ "]],"start1":1240,"start2":1240,"length1":33,"length2":17},{"diffs":[[0,"^ bHi) >>> 0"],[1,"]"],[0,"\n    }\n\n    "]],"start1":1255,"start2":1255,"length1":24,"length2":25},{"diffs":[[0," // "],[-1,"Load"],[1,"Converts"],[0," 8 b"]],"start1":1279,"start2":1279,"length1":12,"length2":16},{"diffs":[[0,"rom "],[-1,"message into lo and hi"],[1,"array starting at offset into two"],[0," 32-"]],"start1":1301,"start2":1301,"length1":30,"length2":41},{"diffs":[[0," (little"],[-1,"-"],[1," "],[0,"endian)\n"]],"start1":1351,"start2":1351,"length1":17,"length2":17},{"diffs":[[0,"mber"],[-1,", out: number[]): void"],[1,"): [number, number]"],[0," {\n "]],"start1":1420,"start2":1420,"length1":30,"length2":27},{"diffs":[[0,"t lo = 0"],[-1,"\n        let"],[1,","],[0," hi = 0\n"]],"start1":1456,"start2":1456,"length1":28,"length2":17},{"diffs":[[0,"|= ("],[-1,"(offset + i < bytes.length) ? "],[0,"byte"]],"start1":1526,"start2":1526,"length1":38,"length2":8},{"diffs":[[0,"offset + i] "],[-1,":"],[1,"||"],[0," 0) << (8 * "]],"start1":1536,"start2":1536,"length1":25,"length2":26},{"diffs":[[0,"|= ("],[-1,"(offset + 4 + i < bytes.length) ? "],[0,"byte"]],"start1":1580,"start2":1580,"length1":42,"length2":8},{"diffs":[[0," 4 + i] "],[-1,":"],[1,"||"],[0," 0) << ("]],"start1":1598,"start2":1598,"length1":17,"length2":18},{"diffs":[[0,"    "],[-1,"out[0] = lo >>> 0\n        out[1] ="],[1,"return [lo >>> 0,"],[0," hi "]],"start1":1637,"start2":1637,"length1":42,"length2":25},{"diffs":[[0," 0, hi >>> 0"],[1,"]"],[0,"\n    }\n\n    "]],"start1":1655,"start2":1655,"length1":24,"length2":25},{"diffs":[[0," // "],[-1,"SipRound updates the state v0,v1,v2,v3 (each is lo,hi) in place\n    function sipround(v0: number[], v1: number[], v2: number[], v3: number[]): void {\n  "],[1,"Converts two 32-bit words back to number (just returns low 32 bits as number)\n"],[0,"    "],[-1,"  "],[0,"// "],[-1,"v0 += v1\n        add64(v0[0], v0[1], v1[0], v1[1], v0)\n        // v1 = ROTL(v1,13)\n        rotl64(v1[0], v1[1], 13, v1)\n        // v1 ^= v0\n        xor64(v1[0], v1[1], v0[0], v0[1], v1)\n        // v0 = ROTL(v0,32)\n        rotl64(v0[0], v0[1], 32, v0)\n\n        // v2 += v3\n        add64(v2[0], v2[1], v3[0], v3[1], v2)\n        // v3 = ROTL(v3,16)\n        rotl64(v3[0], v3[1], 16, v3)\n        // v3 ^= v2\n        xor64(v3[0], v3[1], v2[0], v2[1], v3)\n\n        // v0 += v3\n        add64(v0[0], v0[1], v3[0], v3[1], v0)\n        // v3 = ROTL(v3,21)\n        rotl64(v3[0], v3[1], 21, v3)\n        // v3 ^= v0\n        xor64(v3[0], v3[1], v0[0], v0[1], v3)\n\n        // v2 += v1\n        add64(v2[0], v2[1], v1[0], v1[1], v2)\n        // v1 = ROTL(v1,17)\n        rotl64(v1[0], v1[1], 17, v1)\n        // v1 ^= v2\n        xor64(v1[0], v1[1], v2[0], v2[1], v1)\n        // v2 = ROTL(v2,32)\n        rotl64(v2[0], v2[1], 32, v2)\n    }"],[1,"For simplicity, hash output is truncated to 32 bits\n    // You can extend this to return a hex string combining both parts if needed"],[0,"\n\n  "]],"start1":1679,"start2":1679,"length1":1084,"length2":225},{"diffs":[[0,"ize "],[-1,"v0..v3"],[1,"state"],[0," wit"]],"start1":2037,"start2":2037,"length1":14,"length2":13},{"diffs":[[0,"ith key "],[-1,"xor"],[1,"and"],[0," constan"]],"start1":2048,"start2":2048,"length1":19,"length2":19},{"diffs":[[0," = ["],[-1,"0, 0]\n        let v1 = [0, 0]\n        let v2 = [0, 0]\n        let v3 = [0, 0]\n\n        xor64(KEY0, KEY1,"],[1,"KEY0 ^"],[0," 0x7"]],"start1":2084,"start2":2084,"length1":112,"length2":14},{"diffs":[[0,"36f6d65,"],[1," KEY1 ^"],[0," 0x70736"]],"start1":2098,"start2":2098,"length1":16,"length2":23},{"diffs":[[0,"6575"],[-1,", v0)\n        xor64(KEY2, KEY3,"],[1,"] // low, high\n        let v1 = [KEY2 ^"],[0," 0x6"]],"start1":2120,"start2":2120,"length1":39,"length2":47},{"diffs":[[0,"46f7261,"],[1," KEY3 ^"],[0," 0x6e646"]],"start1":2167,"start2":2167,"length1":16,"length2":23},{"diffs":[[0,"6f6d"],[-1,", v1)"],[1,"]"],[0,"\n   "]],"start1":2189,"start2":2189,"length1":13,"length2":9},{"diffs":[[0,"    "],[-1,"xor64(KEY0, KEY1,"],[1,"let v2 = [KEY0 ^"],[0," 0x6"]],"start1":2199,"start2":2199,"length1":25,"length2":24},{"diffs":[[0,"c796765,"],[1," KEY1 ^"],[0," 0x6e657"]],"start1":2223,"start2":2223,"length1":16,"length2":23},{"diffs":[[0,"6e657261"],[-1,", v2)"],[1,"]"],[0,"\n       "]],"start1":2241,"start2":2241,"length1":21,"length2":17},{"diffs":[[0,"    "],[-1,"xor64(KEY2, KEY3,"],[1,"let v3 = [KEY2 ^"],[0," 0x7"]],"start1":2255,"start2":2255,"length1":25,"length2":24},{"diffs":[[0,"4656462,"],[1," KEY3 ^"],[0," 0x79746"]],"start1":2279,"start2":2279,"length1":16,"length2":23},{"diffs":[[0,"6573"],[-1,", v3)"],[1,"]"],[0,"\n\n"],[-1,"        let mi = [0, 0]\n"],[0,"    "]],"start1":2301,"start2":2301,"length1":39,"length2":11},{"diffs":[[0,"all "],[-1,"full "],[0,"8-by"]],"start1":2351,"start2":2351,"length1":13,"length2":8},{"diffs":[[0,"\n           "],[1," let mi ="],[0," bytesTo64LE"]],"start1":2402,"start2":2402,"length1":24,"length2":33},{"diffs":[[0,", offset"],[-1,", mi"],[0,")\n      "]],"start1":2437,"start2":2437,"length1":20,"length2":16},{"diffs":[[0,"set)\n           "],[1," v3 ="],[0," xor64(v3[0], v3"]],"start1":2442,"start2":2442,"length1":32,"length2":37},{"diffs":[[0,"1], mi[0], mi[1]"],[-1,", v3"],[0,")\n            si"]],"start1":2480,"start2":2480,"length1":36,"length2":32},{"diffs":[[0,"            "],[-1,"sipround("],[1,"["],[0,"v0, v1, v2, "]],"start1":2498,"start2":2498,"length1":33,"length2":25},{"diffs":[[0,", v2, v3"],[-1,")\n           "],[1,"] ="],[0," siproun"]],"start1":2517,"start2":2517,"length1":29,"length2":19},{"diffs":[[0,"d(v0, v1, v2, v3"],[1,", 2"],[0,")\n            xo"]],"start1":2536,"start2":2536,"length1":32,"length2":35},{"diffs":[[0,"\n           "],[1," v0 ="],[0," xor64(v0[0]"]],"start1":2556,"start2":2556,"length1":24,"length2":29},{"diffs":[[0,"], mi[1]"],[-1,", v0"],[0,")\n      "]],"start1":2598,"start2":2598,"length1":20,"length2":16},{"diffs":[[0,"ock "],[-1,"(8 bytes), pad with zeros, last byte is message length mod 256"],[1,"with padding"],[0,"\n   "]],"start1":2667,"start2":2667,"length1":70,"length2":20},{"diffs":[[0,"k = "],[-1,"[0, 0, 0, 0, 0, 0, 0, 0]"],[1,"new Array(8).fill(0)"],[0,"\n   "]],"start1":2704,"start2":2704,"length1":32,"length2":28},{"diffs":[[0,"xff\n\n       "],[1," let mi ="],[0," bytesTo64LE"]],"start1":2889,"start2":2889,"length1":24,"length2":33},{"diffs":[[0,"Block, 0"],[-1,", mi"],[0,")\n      "]],"start1":2927,"start2":2927,"length1":20,"length2":16},{"diffs":[[0,"lock, 0)\n       "],[1," v3 ="],[0," xor64(v3[0], v3"]],"start1":2928,"start2":2928,"length1":32,"length2":37},{"diffs":[[0,"], mi[1]"],[-1,", v3"],[0,")\n      "]],"start1":2974,"start2":2974,"length1":20,"length2":16},{"diffs":[[0,"1])\n        "],[-1,"sipround("],[1,"["],[0,"v0, v1, v2, "]],"start1":2980,"start2":2980,"length1":33,"length2":25},{"diffs":[[0,", v1, v2, v3"],[-1,")\n       "],[1,"] ="],[0," sipround(v0"]],"start1":2995,"start2":2995,"length1":33,"length2":27},{"diffs":[[0,"d(v0, v1, v2, v3"],[1,", 2"],[0,")\n        xor64("]],"start1":3018,"start2":3018,"length1":32,"length2":35},{"diffs":[[0,", v3, 2)\n       "],[1," v0 ="],[0," xor64(v0[0], v0"]],"start1":3030,"start2":3030,"length1":32,"length2":37},{"diffs":[[0,"], mi[1]"],[-1,", v0"],[0,")\n\n     "]],"start1":3076,"start2":3076,"length1":20,"length2":16},{"diffs":[[0,"    "],[-1,"// Finalization\n       "],[1,"v2 ="],[0," xor"]],"start1":3091,"start2":3091,"length1":31,"length2":12},{"diffs":[[0," 0xff, 0"],[-1,", v2"],[0,")\n\n     "]],"start1":3119,"start2":3119,"length1":20,"length2":16},{"diffs":[[0,"0)\n\n        "],[-1,"sipround("],[1,"["],[0,"v0, v1, v2, "]],"start1":3126,"start2":3126,"length1":33,"length2":25},{"diffs":[[0,", v1, v2, v3"],[-1,")\n       "],[1,"] ="],[0," sipround(v0"]],"start1":3141,"start2":3141,"length1":33,"length2":27},{"diffs":[[0,"d(v0, v1, v2, v3"],[-1,")"],[1,", 4)\n"],[0,"\n        siproun"]],"start1":3164,"start2":3164,"length1":33,"length2":37},{"diffs":[[0,"    "],[-1,"sipround(v0, v1, v2, v3)\n        sipround(v0, v1, v2, v3)\n\n        // Compute final result = v0 ^ v1 ^ v2 ^ v3\n        let tLo = 0"],[1,"let result = xor64(xor64(v0[0], v0[1], v1[0], v1[1])[0], xor64(v0[0], v0[1], v1[0], v1[1])[1],\n            xor64(v2[0], v2[1], v3[0], v3[1])[0], xor64(v2[0], v2[1], v3[0], v3[1])[1])\n\n        // Return low 32 bits\n        return result[0] >>> 0\n    }\n\n    // SipRound function: mutates state 2-4 times\n    function sipround(v0: [number, number], v1: [number, number], v2: [number, number], v3: [number, number], rounds: number): [[number, number], [number, number], [number, number], [number, number]] {"],[0,"\n   "]],"start1":3190,"start2":3190,"length1":138,"length2":511},{"diffs":[[0,"    "],[1,"for ("],[0,"let "],[-1,"tH"],[0,"i = 0"],[-1,"\n        let temp = "],[1,"; i < rounds; i++) {\n            let res = add64(v0"],[0,"[0"],[1,"]"],[0,", "],[-1,"0]\n\n        xor"],[1,"v0[1], v1[0], v1[1])\n            v0 = res\n            v1 = rotl"],[0,"64(v"],[-1,"0"],[1,"1"],[0,"[0], v"],[-1,"0"],[1,"1"],[0,"[1], "],[-1,"v1[0], v1[1], temp)\n        tLo = temp[0]\n        tHi = temp[1]\n\n        xor64(tLo, tHi"],[1,"13)\n            v1 = xor64(v1[0], v1[1], v0[0], v0[1])\n            v0 = rotl64(v0[0], v0[1], 32)\n\n            res = add64(v2[0], v2[1], v3[0], v3[1])\n            v2 = res\n            v3 = rotl64(v3[0], v3[1], 16)\n            v3 = xor64(v3[0], v3[1]"],[0,", v2"]],"start1":3702,"start2":3702,"length1":162,"length2":406},{"diffs":[[0,"2[1]"],[-1,", temp"],[0,")\n"],[1,"\n"],[0,"        "],[-1,"tLo = temp[0]\n        tHi = temp[1]\n\n"],[1,"    res = add64(v0[0], v0[1], v3[0], v3[1])\n            v0 = res\n            v3 = rotl64(v3[0], v3[1], 21)\n    "],[0,"       "],[1," v3 ="],[0," xor64("],[-1,"tLo, tHi, v3"],[1,"v3[0], v3[1], v0[0], v0[1])\n\n            res = add64(v2"],[0,"[0], v"],[-1,"3"],[1,"2"],[0,"[1], "],[-1,"temp)\n        tLo = temp[0]\n        tHi = temp[1]\n\n        // Return low 32 bits of final hash\n        return tLo >>> 0\n    }\n\n    // UTF-8 encoding helper"],[1,"v1[0], v1[1])\n            v2 = res\n            v1 = rotl64(v1[0], v1[1], 17)\n            v1 = xor64(v1[0], v1[1], v2[0], v2[1])\n            v2 = rotl64(v2[0], v2[1], 32)\n        }\n        return [v0, v1, v2, v3]\n    }\n\n    // Convert string to UTF-8 byte array"],[0,"\n   "]],"start1":4114,"start2":4114,"length1":254,"length2":476},{"diffs":[[0,"}\n\n\n"],[-1,"radio.setTransmitSerialNumber(false)\n\nradio.onReceivedString\n"],[1,"let deviceNum = control.deviceSerialNumber()\ndeviceNum = deviceNum.toString()\nlet key = siphash.hash(deviceNum)\n\nconsole.log(deviceNum)\nconsole.log(key)"],[0,"\n\n"]],"start1":5184,"start2":5184,"length1":67,"length2":158}]}]},{"timestamp":1749754511424,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"sh {"],[-1," //siphash algorithm, generated by chatgpt"],[0,"\n   "]],"start1":15,"start2":15,"length1":50,"length2":8},{"diffs":[[0,"}\n\n\n"],[-1,"\nconst correctHash = 0 // set this to the hash of the correct "],[1,"radio.setTransmit"],[0,"Serial"],[-1," "],[0,"Number"],[-1,"\n\n"],[1,"(false)"],[0,"\n\nra"]],"start1":5680,"start2":5680,"length1":85,"length2":44},{"diffs":[[0,"ring"],[-1,"(function(recv) { // \n    let hashedSerial = siphash.hash(radio.receivedPacket(RadioPacketProperty.SerialNumber).toString())\n\n    if (hashedSerial != correctHash) {return}\n\n    //code to run\n\n})"],[0,"\n\n\n"]],"start1":5740,"start2":5740,"length1":201,"length2":7}]}]},{"timestamp":1749755144106,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":203,"start2":203,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1749753369978,"editorVersion":"7.0.61","text":{"main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"siphash\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1749755144112}