namespace siphash { //siphash algorithm, generated by chatgpt
    // Hardcoded 128-bit key split into four 32-bit parts (little-endian)
    const KEY0 = 0x07060504
    const KEY1 = 0x03020100
    const KEY2 = 0x0f0e0d0c
    const KEY3 = 0x0b0a0908

    // Rotate left 32-bit
    function rotl(x: number, b: number): number {
        return ((x << b) | (x >>> (32 - b))) >>> 0
    }

    // Rotate left 64-bit represented by lo and hi parts
    function rotl64(lo: number, hi: number, b: number, out: number[]): void {
        b = b % 64
        if (b == 0) {
            out[0] = lo
            out[1] = hi
        } else if (b < 32) {
            out[0] = ((lo << b) | (hi >>> (32 - b))) >>> 0
            out[1] = ((hi << b) | (lo >>> (32 - b))) >>> 0
        } else if (b == 32) {
            out[0] = hi
            out[1] = lo
        } else {
            let bb = b - 32
            out[0] = ((hi << bb) | (lo >>> (32 - bb))) >>> 0
            out[1] = ((lo << bb) | (hi >>> (32 - bb))) >>> 0
        }
    }

    // 64-bit addition with carry
    function add64(aLo: number, aHi: number, bLo: number, bHi: number, out: number[]): void {
        let lo = (aLo + bLo) >>> 0
        let carry = 0
        if (lo < aLo) carry = 1
        let hi = (aHi + bHi + carry) >>> 0
        out[0] = lo
        out[1] = hi
    }

    // 64-bit xor
    function xor64(aLo: number, aHi: number, bLo: number, bHi: number, out: number[]): void {
        out[0] = (aLo ^ bLo) >>> 0
        out[1] = (aHi ^ bHi) >>> 0
    }

    // Load 8 bytes from message into lo and hi 32-bit words (little-endian)
    function bytesTo64LE(bytes: number[], offset: number, out: number[]): void {
        let lo = 0
        let hi = 0
        for (let i = 0; i < 4; i++) {
            lo |= ((offset + i < bytes.length) ? bytes[offset + i] : 0) << (8 * i)
            hi |= ((offset + 4 + i < bytes.length) ? bytes[offset + 4 + i] : 0) << (8 * i)
        }
        out[0] = lo >>> 0
        out[1] = hi >>> 0
    }

    // SipRound updates the state v0,v1,v2,v3 (each is lo,hi) in place
    function sipround(v0: number[], v1: number[], v2: number[], v3: number[]): void {
        // v0 += v1
        add64(v0[0], v0[1], v1[0], v1[1], v0)
        // v1 = ROTL(v1,13)
        rotl64(v1[0], v1[1], 13, v1)
        // v1 ^= v0
        xor64(v1[0], v1[1], v0[0], v0[1], v1)
        // v0 = ROTL(v0,32)
        rotl64(v0[0], v0[1], 32, v0)

        // v2 += v3
        add64(v2[0], v2[1], v3[0], v3[1], v2)
        // v3 = ROTL(v3,16)
        rotl64(v3[0], v3[1], 16, v3)
        // v3 ^= v2
        xor64(v3[0], v3[1], v2[0], v2[1], v3)

        // v0 += v3
        add64(v0[0], v0[1], v3[0], v3[1], v0)
        // v3 = ROTL(v3,21)
        rotl64(v3[0], v3[1], 21, v3)
        // v3 ^= v0
        xor64(v3[0], v3[1], v0[0], v0[1], v3)

        // v2 += v1
        add64(v2[0], v2[1], v1[0], v1[1], v2)
        // v1 = ROTL(v1,17)
        rotl64(v1[0], v1[1], 17, v1)
        // v1 ^= v2
        xor64(v1[0], v1[1], v2[0], v2[1], v1)
        // v2 = ROTL(v2,32)
        rotl64(v2[0], v2[1], 32, v2)
    }

    export function hash(message: string): number {
        let m = stringToBytes(message)
        let b = m.length

        // Initialize v0..v3 with key xor constants
        let v0 = [0, 0]
        let v1 = [0, 0]
        let v2 = [0, 0]
        let v3 = [0, 0]

        xor64(KEY0, KEY1, 0x736f6d65, 0x70736575, v0)
        xor64(KEY2, KEY3, 0x646f7261, 0x6e646f6d, v1)
        xor64(KEY0, KEY1, 0x6c796765, 0x6e657261, v2)
        xor64(KEY2, KEY3, 0x74656462, 0x79746573, v3)

        let mi = [0, 0]
        let offset = 0

        // Process all full 8-byte blocks
        while (offset + 8 <= b) {
            bytesTo64LE(m, offset, mi)
            xor64(v3[0], v3[1], mi[0], mi[1], v3)
            sipround(v0, v1, v2, v3)
            sipround(v0, v1, v2, v3)
            xor64(v0[0], v0[1], mi[0], mi[1], v0)
            offset += 8
        }

        // Build last block (8 bytes), pad with zeros, last byte is message length mod 256
        let lastBlock = [0, 0, 0, 0, 0, 0, 0, 0]
        let remaining = b - offset
        for (let i = 0; i < remaining; i++) {
            lastBlock[i] = m[offset + i]
        }
        lastBlock[7] = b & 0xff

        bytesTo64LE(lastBlock, 0, mi)
        xor64(v3[0], v3[1], mi[0], mi[1], v3)
        sipround(v0, v1, v2, v3)
        sipround(v0, v1, v2, v3)
        xor64(v0[0], v0[1], mi[0], mi[1], v0)

        // Finalization
        xor64(v2[0], v2[1], 0xff, 0, v2)

        sipround(v0, v1, v2, v3)
        sipround(v0, v1, v2, v3)
        sipround(v0, v1, v2, v3)
        sipround(v0, v1, v2, v3)

        // Compute final result = v0 ^ v1 ^ v2 ^ v3
        let tLo = 0
        let tHi = 0
        let temp = [0, 0]

        xor64(v0[0], v0[1], v1[0], v1[1], temp)
        tLo = temp[0]
        tHi = temp[1]

        xor64(tLo, tHi, v2[0], v2[1], temp)
        tLo = temp[0]
        tHi = temp[1]

        xor64(tLo, tHi, v3[0], v3[1], temp)
        tLo = temp[0]
        tHi = temp[1]

        // Return low 32 bits of final hash
        return tLo >>> 0
    }

    // UTF-8 encoding helper
    function stringToBytes(str: string): number[] {
        let bytes: number[] = []
        for (let i = 0; i < str.length; i++) {
            let code = str.charCodeAt(i)
            if (code < 0x80) {
                bytes.push(code)
            } else if (code < 0x800) {
                bytes.push(0xc0 | (code >> 6))
                bytes.push(0x80 | (code & 0x3f))
            } else {
                bytes.push(0xe0 | (code >> 12))
                bytes.push(0x80 | ((code >> 6) & 0x3f))
                bytes.push(0x80 | (code & 0x3f))
            }
        }
        return bytes
    }
}



const correctHash = 0 // set this to the hash of the correct Serial Number



radio.onReceivedString(function(recv) { // 
    let hashedSerial = siphash.hash(radio.receivedPacket(RadioPacketProperty.SerialNumber).toString())

    if (hashedSerial != correctHash) {return}

    //code to run

})


